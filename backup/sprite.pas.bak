unit sprite;
//------------------------------------------------------------------------------
interface
//------------------------------------------------------------------------------
uses
  SysUtils, Classes, Types, Controls, Graphics, ExtCtrls, ComCtrls, DbCtrls, StdCtrls;
//------------------------------------------------------------------------------
type
TSense= (seNone, seRight, SeLeft, SeUp, SeDown);
TSprite= class(TControl)
private
  FFrame: TBitmap;
  FSpriteSheet: TBitmap;
  FHeadSprite: TBitmap;
  FSpriteHead: ShortString;
  FSpriteCloth: ShortString;
  FFrameCount: Integer;
  FFrameNumber: Integer;
  FFramesPerSense: Integer;
  FTimer: TTimer;
  FLoop: Boolean;
  FInterval: Cardinal;
  FReverse: Boolean;
  FSense: TSense;
  FStartFrame: Integer;
  FEndFrame: Integer;
  FrameX: Integer;
  FrameY: Integer;
  FFrameWidth: Integer;
  FFrameHeight: Integer;
  FFlippedX : Boolean;
  FFlippedY : Boolean;
  procedure OnTimer;
  procedure SetInterval(const Value: Cardinal);
  procedure SetLoop(const Value: Boolean);
  procedure SetFrameSize(index: integer);
protected
  procedure DrawFrame(Number: Integer);
  procedure Paint;
  procedure FFrameChanged; virtual;
public
  constructor Create(AOwner: TComponent); override;
  destructor Destroy; override;
  procedure NextFrame;
  procedure PriorFrame;
  procedure Motion;
  procedure FrameRange;
  procedure Still;
  procedure MoveToFrame(Value: Integer);
  procedure LoadSprite; overload;
  procedure LoadSprite(const Img: TBitmap); overload;
published
  property FrameWidth: Integer read FFrameWidth write FFrameWidth;
  property FrameHeight: Integer read FFrameHeight write FFrameHeight;
  property FrameCount: Integer read FFrameCount write FFrameCount;
  property FrameNumber: Integer read FFrameNumber write FFrameNumber;
  property Reverse: Boolean read FReverse write FReverse;
  property FlippedX: Boolean read FFlippedX write FFlippedX;
  property FlippedY: Boolean read FFlippedY write FFlippedY;
  property Interval: Cardinal read FInterval write SetInterval;
  property Loop: Boolean read FLoop write SetLoop;
  property Sense: TSense read FSense write FSense;
  property Cloth: ShortString read FSpriteCloth write FSpriteCloth;
  property Head: ShortString read FSpriteHead write FSpriteHead;
  property FramesPerSense: Integer read FFramesPerSense write FFramesPerSense;
  property SpriteSheet: TBitmap read FSpriteSheet;
end;
//------------------------------------------------------------------------------
procedure Register;
//------------------------------------------------------------------------------
implementation

//------------------------------------------------------------------------------
constructor TSprite.Create(AOwner: TComponent);
begin
  inherited;
  FFrame:= TBitmap.Create;
  FSpriteSheet:= TBitmap.Create;
  FHeadSprite:= TBitmap.Create;
  if not (csDesigning in ComponentState) then
    begin
    FTimer:= TTimer.Create(AOwner);

    FTimer.Interval:= FInterval;
    FTimer.Enabled:= False;
    end;
  FLoop:= False;
  FReverse:= False;
  FSense:= seRight;
  FFramesPerSense:= 3;
  FFrameWidth:= 32;
  FFrameHeight:= 32;
  //FFrame.OnChange:= FFrameChanged;

end;
//------------------------------------------------------------------------------
procedure TSprite.DrawFrame(Number: Integer);
begin
  SetFrameSize(Number);
  FFrameNumber:= Number;
  Width:= FFrame.Width;
  Height:= FFrame.Height;
 // FFrame.Clear(clanull);

  FFrame.Canvas.DrawBitmap(FSpriteSheet,
        RectF(FrameX, FrameY, FrameX + FFrame.Width, FrameY + FFrame.Height),
        RectF(0, 0, FFrame.Width , FFrame.Height), 1);
  FFrame.Canvas.DrawBitmap(FHeadSprite,
        RectF(FrameX, FrameY, FrameX + FFrame.Width, FrameY + FFrame.Height),
        RectF(0, 0, FFrame.Width , FFrame.Height), 1);
  FFrame.Canvas.EndScene;
  if FFlippedX then FFrame.FlipHorizontal;
  if FFlippedY then FFrame.FlipVertical;
  Repaint;
end;
//------------------------------------------------------------------------------
procedure TSprite.Still;
begin
  DrawFrame(0);
end;
//------------------------------------------------------------------------------
Procedure TSprite.SetFrameSize(Index: Integer);
begin
  case Index of
  0: begin FrameX:= 0; FrameY:= 0; end;
  1: begin FrameX:= 32; FrameY:= 0; end;
  2: begin FrameX:= 64; FrameY:= 0; end;
  3: begin FrameX:= 0; FrameY:= 32; end;
  4: begin FrameX:= 32; FrameY:= 32; end;
  5: begin FrameX:= 64; FrameY:= 32; end;
  6: begin FrameX:= 0; FrameY:= 64; end;
  7: begin FrameX:= 32; FrameY:= 64; end;
  8: begin FrameX:= 64; FrameY:= 64; end;
  9: begin FrameX:= 0; FrameY:= 96; end;
  10: begin FrameX:= 32; FrameY:= 96; end;
  11: begin FrameX:= 64; FrameY:= 96; end;
  end;
  FFrame.Width:= FFrameWidth;
  FFrame.Height:= FFrameHeight;
end;
//------------------------------------------------------------------------------
procedure TSprite.NextFrame;
begin
  FrameRange;
  if FFrameNumber< FEndFrame then
    DrawFrame(FFrameNumber+1)
  else
  FFrameNumber:= FStartFrame;
end;
//------------------------------------------------------------------------------
procedure TSprite.PriorFrame;
begin
  FrameRange;
  if FFrameNumber> FStartFrame then
    DrawFrame(FFrameNumber-1)
  else
  FFrameNumber:= FEndFrame;
end;
//------------------------------------------------------------------------------
procedure TSprite.MoveToFrame(Value: Integer);
begin
  FrameRange;
  if (Value<= FEndFrame) and (Value>= FStartFrame) then
    DrawFrame(Value);
end;
//------------------------------------------------------------------------------
procedure TSprite.FrameRange;
begin
  case FSense of
  seNone, seDown: begin FStartFrame:= 0; FEndFrame:= FFramesPerSense-1; end;
  seLeft: begin FStartFrame:= FFramesPerSense; FEndFrame:= (FFramesPerSense*2)-1; end;
  seRight: begin FStartFrame:= (FFramesPerSense*2); FEndFrame:= (FFramesPerSense*3)-1; end;
  seUp: begin FStartFrame:= (FFramesPerSense*3); FEndFrame:= (FFramesPerSense*4)-1; end;
  end;
end;
//------------------------------------------------------------------------------
procedure TSprite.Motion;
begin
  FrameRange;
  if FReverse then
    begin
    if FFrameNumber<= FStartFrame then FFrameNumber:= FEndFrame;
    DrawFrame(FFrameNumber);
    Dec(FFrameNumber);
    end
    else
    begin
    if FFrameNumber>= FEndFrame then FFrameNumber:= FStartFrame;
    DrawFrame(FFrameNumber);
    Inc(FFrameNumber);
    end;
end;
//------------------------------------------------------------------------------
procedure TSprite.OnTimer(Sender: TObject);
begin
  Motion;
end;
//------------------------------------------------------------------------------
destructor TSprite.Destroy;
begin
  FFrame.Free;
  FSpriteSheet.Free;
  FHeadSprite.Free;
  FreeAndNil(FTimer);
  inherited;
end;
//------------------------------------------------------------------------------
procedure TSprite.Paint;
var
  DrawArea: TRectF;
  State: TCanvasSaveState;
  R: TRectF;
begin
  if (csDesigning in ComponentState) and not Locked and not FInPaintTo then
    begin
    R:= LocalRect;
    InflateRect(R, -0.5, -0.5);
    Canvas.StrokeThickness:= 2;
    Canvas.Stroke.Kind:= TBrushKind.bkSolid;
    Canvas.Stroke.Color:= $A0909090;
    Canvas.DrawRect(R, 0, 0, AllCorners, AbsoluteOpacity);
    Canvas.StrokeDash:= TStrokeDash.sdSolid;
    Canvas.FillText(R, 'TSprite', false, 100, [], TTextAlign.taLeading,TTextAlign.taCenter);
    end;
  if FFrame.IsEmpty then Exit;
  State:= Canvas.SaveState;
  Canvas.IntersectClipRect(LocalRect);
  DrawArea:= RectF(0, 0, FFrame.Width, FFrame.Height);
  Canvas.DrawBitmap(FFrame, RectF(0, 0, FFrame.Width, FFrame.Height), DrawArea,
    AbsoluteOpacity, True);
  Canvas.RestoreState(State);
end;
//------------------------------------------------------------------------------
procedure TSprite.SetInterval(const Value: Cardinal);
begin
  if not (csDesigning in ComponentState) then
    FTimer.Interval:= Value
  else
    FInterval:= Value;
end;
//------------------------------------------------------------------------------
procedure TSprite.SetLoop(const Value: Boolean);
begin
  if not (csDesigning in ComponentState) then
    FTimer.Enabled:= Value
  else
    FLoop:= Value;
end;
//------------------------------------------------------------------------------
procedure TSprite.FFrameChanged(Sender: TObject);
begin
  Repaint;
  UpdateEffects;
end;
//------------------------------------------------------------------------------
procedure TSprite.LoadSprite;
var
  Head: TBitmap;
begin
  FSpriteSheet.LoadFromFile('C:\Users\runs\Documents\RAD Studio\Projects\LibreRPG\img\sprites\cloth\'+ FSpriteCloth+'.png');
  FHeadSprite.LoadFromFile('C:\Users\runs\Documents\RAD Studio\Projects\LibreRPG\img\sprites\head\'+ FSpriteHead+'.png');
end;
//------------------------------------------------------------------------------
procedure TSprite.LoadSprite(const Img: TBitmap);
begin
  FSpriteSheet.Assign(Img);
end;
//------------------------------------------------------------------------------
procedure Register;
begin
  RegisterComponents('LibreRPG', [TSprite]);
end;
//------------------------------------------------------------------------------
end.

